<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>浅谈《守望先锋》中的 ECS 构架</title>
      <link href="/2018/10/15/%E6%B5%85%E8%B0%88%E3%80%8A%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B%E3%80%8B%E4%B8%AD%E7%9A%84%20ECS%20%E6%9E%84%E6%9E%B6/"/>
      <url>/2018/10/15/%E6%B5%85%E8%B0%88%E3%80%8A%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B%E3%80%8B%E4%B8%AD%E7%9A%84%20ECS%20%E6%9E%84%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red">转载自</font><a href="https://blog.codingnow.com/2017/06/overwatch_ecs.html" target="_blank" rel="noopener">云风的 BLOG</a></p></blockquote><p>今天读了一篇 《守望先锋》架构设计与网络同步 。这是根据 GDC 2017 上的演讲 Overwatch Gameplay Architecture and Netcode 视频翻译而来的，所以并没有原文。由于是个一小时的演讲，不可能讲得面面俱到，所以理解起来有些困难，我反复读了三遍，然后把英文视频找来（订阅 GDC Vault 可以看，有版权）看了一遍，大致理解了 ECS 这个框架。写这篇 Blog 记录一下我对 ECS 的理解，结合我自己这些年做游戏开发的经验，可能并非等价于原演讲中的思想。</p><a id="more"></a><p><code>Entity Component System (ECS)</code> 是一个 gameplay 层面的框架，它是建立在渲染引擎、物理引擎之上的，主要解决的问题是如何建立一个模型来处理游戏对象 (Game Object) 的更新操作。</p><p>传统的很多游戏引擎是基于面向对象来设计的，游戏中的东西都是对象，每个对象有一个叫做 Update 的方法，框架遍历所有的对象，依次调用其 Update 方法。有些引擎甚至定义了多种 Update 方法，在同一帧的不同时机去调用。</p><p>这么做其实是有极大的缺陷的，我相信很多做过游戏开发的程序都会有这种体会。因为游戏对象其实是由很多部分聚合而成，引擎的功能模块很多，不同的模块关注的部分往往互不相关。比如渲染模块并不关心网络连接、游戏业务处理不关心玩家的名字、用的什么模型。从自然意义上说，把游戏对象的属性聚合在一起成为一个对象是很自然的事情，对于这个对象的生命期管理也是最合理的方式。但对于不同的业务模块来说，针对聚合在一起的对象做处理，把处理方法绑定在对象身上就不那么自然了。这会导致模块的内聚性很差、模块间也会出现不必要的耦合。</p><p>我觉得守望先锋之所以要设计一个新的框架来解决这个问题，是因为他们面对的问题复杂度可能到了一个更高的程度：比如如何用预测技术做更准确的网络同步。网络同步只关心很少的对象属性，没必要在设计同步模块时牵扯过多不必要的东西。为了准确，需要让客户端和服务器跑同一套代码，而服务器并不需要做显示，所以要比较容易的去掉显示系统；客户端和服务器也不完全是同样的逻辑，需要共享一部分系统，而在另一部分上根据分别实现……</p><p>总的来说、需要想一个办法拆分复杂问题，把问题聚焦到一个较小的集合，提高每个子任务的内聚性。</p><p>ECS 的 E ，也就是 Entity ，可以说就是传统引擎中的 Game Object 。但在这个系统下，它仅仅是 C/Component 的组合。它的意义在于生命期管理，这里是用 32bit ID 而不是指针来表示的，另外附着了渲染用到的资源 ID 。因为仅负责生命期管理，而不设计调用其上的方法，用整数 ID 更健壮。整数 ID 更容易指代一个无效的对象，而指针就很难做到。</p><p>C 和 S 是这个框架的核心。System 系统，也就是我上面提到的模块。对于游戏来说，每个模块应该专注于干好一件事，而每件事要么是作用于游戏世界里同类的一组对象的每单个个体的，要么是关心这类对象的某种特定的交互行为。比如碰撞系统，就只关心对象的体积和位置，不关心对象的名字，连接状态，音效、敌对关系等。它也不一定关心游戏世界中的所有对象，比如关心那些不参与碰撞的装饰物。所以对每个子系统来说，筛选出系统关心的对象子集以及只给它展示它所关心的数据就是框架的责任了。</p><p>在 ECS 框架中，把每个可能单独使用的对象属性归纳为一个个 Component ，比如对象的名字就是一个 Component ，对象的位置状态是另一个 Component 。每个 Entity 是由多个 Component 组合而成，共享一个生命期；而 Component 之间可以组合在一起作为 System 筛选的标准。我们在开发的时候，可以定义一个 System 关心某一个固定 Component 的组合；那么框架就会把游戏世界中满足有这个组合的 Entity 都筛选出来供这个 System 遍历，如果一个 Entity 只具备这组 Component 中的一部分，就不会进入这个筛选集合，也就不被这个 System 所关心了。</p><p>在演讲中，作者谈到了一个根据输入状态来决定是不是要把长期不产生输入的对象踢下线的例子，就是要对象同时具备连接组件、输入组件等，然后这个 AFK 处理系统遍历所有符合要求的对象，根据最近输入事件产生的时间，把长期没有输入事件的对象通知下线；他特别说到，AI 控制的机器人，由于没有连接组件，虽然具备状态组件，但不满足 AFK 系统要求的完整组件组的要求，就根本不会遍历到，也就不用在其上面浪费计算资源了。我认为这是 ECS 相对传统对象 Update 模型的一点优势；用传统方法的话，很可能需要写一个空的 Update 函数。</p><p>游戏的业务循环就是在调用很多不同的系统，每个系统自己遍历自己感兴趣的对象，只有预定义的组件部分可以被子系统感知到，这样每个系统就能具备很强的内聚性。注意、这和传统的面向对象或是 Actor 模型是截然不同的。OO 或 Actor 强调的是对象自身处理自身的业务，然后框架去管理对象的集合，负责用消息驱动它们。而在 ECS 中，每个系统关注的是不同的对象集合，它处理的对象中有共性的切片。这是很符合守望先锋这种 MOBA 类游戏的。这类游戏关注的是对象间的关系，比如 A 攻击了 B 对 B 造成了伤害，这件事情是在 A 和 B 之间发生的，在传统模型中，你会纠结于伤害计算到底在 A 对象的方法中完成还是在 B 的方法中完成。而在 ECS 中不需要纠结，因为它可以在伤害计算这个 System 中完成，这个 System 关注的是所有对象中，和伤害的产生有关的那一小部分数据的集合。</p><p>ECS 的设计就是为了管理复杂度，它提供的指导方案就是 Component 是纯数据组合，没有任何操作这个数据的方法；而 System 是纯方法组合，它自己没有内部状态。它要么做成无副作用的纯函数，根据它所能见到的对象 Component 组合计算出某种结果；要么用来更新特定 Component 的状态。System 之间也不需要相互调用（减少耦合），是由游戏世界（外部框架）来驱动若干 System 的。如果满足了这些前提条件，每个 System 都可以独立开发，它只需要遍历给框架提供给它的组件集合，做出正确的处理，更新组件状态就够了。编写 Gameplay 的人更像是在用胶水粘合这些 System ，他只要清楚每个 System 到底做了什么，操作本身对哪些 Component 造成了影响，正确的书写 System 的更新次序就可以了。一个 System 对大多数 Component 是只读的，只对少量 Component 是会改写的，这个可以预先定义清楚，有了这个知识，一是容易管理复杂度，二是给并行处理留下了优化空间。</p><p>在演讲中谈到了开发团队对 ECS 的设计认知也是逐步演进的。</p><p>比如在一开始，他们认为 Component 就是大量有某种同类 Entity 属性的集合的筛选器。ECS 框架辅助这个筛选过程，每个 System 模块都用 for each 的方式迭代相关的 Entity 中对象的组件。之后他们发现，其实对于每个游戏对象集合体来说，一类 Component 可以也应该只有一个。比如存放玩家键盘输入的 Component ，就没有多个。很多 System 都需要去读这个唯一的 Component 内的状态（哪些按钮被按下了），可以安排一个 System 来更新这个 Component 。原文把这种 Component 成为 Singleton Component ，我认为这个东西和一开始 ECS 想解决的问题还是有一些差别的：不同种类的 Entity 分别拥有同类的属性组，框架负责管理同类集合。我们的确还是可以创建一个叫做玩家键盘的 Entity 加到游戏世界中，这个 Entity 是由键盘组件构成。但是我们完全不必迭代玩家键盘这个 Entity 集合，因为它肯定只有一个，直接把这个对象放在游戏世界中即可。但把它放在 System 中就不是一个好设计了。因为它破坏了 System 无状态的设计原则，而且也不支持多个游戏世界：在原文中举了个例子，实际游戏和游戏回放就是两个不同的游戏世界，不同的游戏世界意味着不同的业务流程的组合，需要用不同的方式粘合已经开发好的 System 。把游戏键盘状态这种状态内置在特定的 System 中就是不合适的了。从这个角度来说 ECS 的本质还是数据 C 和操作 S 分离。而操作 S 并不局限于对同类组件集合的管理，也可是是针对单个组件。作者自己也说，最终有 40% 的组件就是单件。</p><p>单件本身其实就和传统面向对象模型差不多了。但是数据和方法分离还是很有意义。我们在用面向对象模式做开发的时候也会碰到一个对象有几个不同的方法，某些方法关注这部分状态、另一些方法关注另一部分状态，还有一些方法关注前面几组状态的集合。这里的方法就是 ECS 中的系统、状态就是组件。将数据和方法分离可以将不同的方法解耦。如果用传统的 C++ 的面向对象模式，很可能需要用多继承、组合转发等等复杂的语法手段。</p><hr><p>演讲后面还提到了一些 ECS 模式下处理一些复杂问题的常见手法。</p><p>Component 没有方法，而 System 则没有状态，只是对定义好的 Component 状态的加工过程。而许多 System 中很可能会处理同一类问题，涉及的 Component 类型是相同的。如果这个有共性的问题只涉及一个 Entity ，那么直观的方法是设计一个 System ，迭代，逐个把结果计算出来，存为 Component 的状态，别的 System 可以在后续把这个结果作为一个状态读出来就可以了。</p><p>但如果这个行为涉及多个 Entity ，比如在不同的 System 中，都需要查询两个 Entity 的敌对关系。我们不可能用一个 System 计算出所有 Entity 间的敌对关系，这样必然产生了大量不必要的计算；又或者这个行为并不想额外修改 Component 的状态，希望对它保持无副作用，比如我想持续模拟一个对象随时间流逝的位置变化，就不能用一个 System 计算好，再从另一个 System 读出来。</p><p>这样，就引入了 Utility 函数的概念，来做上面这种类型的操作，再把 Utility 函数共享给不同的 System 调用。为了降低系统复杂度，就要求要么这种函数是无副作用的，随便怎么调用都没问题，比如上面查询敌对关系的例子；要么就限制调用这种函数的地方，仅在很少的地方调用，由调用者小心的保证副作用的影响，比如上面那个持续位置变化的过程。</p><p>如果产生状态改变这种副作用的行为必须存在时，又在很多 System 中都会触发，那么为了减少调用的地方，就需要把真正产生副作用的点集中在一处了。这个技巧就是推迟行为的发生时机。就是把行为发生时需要的状态保存起来，放在队列里，由一个单独的 System 在独立的环节集中处理它们。</p><p>例如不同的射击行为都可能创建出新的对象、破坏场景、影响已有对象的状态。在同一面墙上留下不同的弹孔，不需要堆叠在一起，而只需要保留最后一个，删除前面的。我们可以把让不同的 System 触发这些对象创建、删除的行为，但并不真正去做。集中在一起推迟到当前帧的末尾或下一帧的开头来做。这样就尽量保证了多数 System 工作的时候，对大多数组件来说是无副作用的，而把严重副作用的行为集中在单点小心处理。</p><hr><p>ECS 要解决的最复杂，最核心的问题，或许还是网络同步。我认为这也是设计一个状态和行为严格分离的框架的主要动机。因为一个好的网络同步系统必须实现预测、有预测就有预测失败的情况，发生后要解决冲突，回滚状态是必须支持的。而状态回滚还包括了只回滚部分状态，而不能简单回滚整个世界。</p><p>我在去年其实在本 blog 中谈过这个问题 。我的观点是，状态的单独保存是非常重要的。在 ECS 模型中，C 是纯数据，所以非常方便做快照和回滚。Entity 的组件分离，也适合做关键状态的记录。去年和一个同事一起做了一个射击类的 MOBA demo ，最终的实现方案就是把游戏对象的位置（移动）状态，和射击状态专门抽出来实现预测同步，效果非常不错。</p><p>这个演讲其实并没有谈及预测和同步的具体技术，而是谈 ECS 怎么帮助降低利用这些技术的实现复杂度。同时也提及了一些有趣的细节。</p><p>比如说，ECS 规定每个需要根据输入表现的 System 都提供了一个 UpdateFixed 函数。守望先锋的同步逻辑是基于 60fps 的，所以这个 UpdateFixed 函数会每 16ms 调用一次，专门用于计算这个逻辑帧的状态。服务器会根据玩家延迟，稍微推迟一点时间，比客户端晚一些调用 UpdateFixed 。在我去年谈同步的 blog 中也说过，玩家其实不关心各个客户端和服务器是不是时刻上绝对一致（绝对一致是不可能做到的），而关心的是，不同客户端和服务器是不是展现了相同的过程。就像直播电影，不同的位置早点播放和晚点播放，大家看到的内容是一致的就够了，是不是同时在观看并不重要。</p><p>但是，游戏和电影不一样的地方是，玩家自己的操作影响了电影的情节。我们需要在服务器仲裁玩家的输入对世界的影响。玩家需要告知服务器的是，我这个操作是在电影开场的几分几秒下达的，服务器按这个时刻，把操作插入到世界的进程中。如果客户端等待服务器回传操作结果那就实在是太卡了，所以客户端要在操作下达后自己模拟后果。如果操作不被打断，其实客户端模拟的结果和服务器仲裁后的结果是一样的，这样服务器在回传后告之客户端过去某个时间点的对象的状态，其实和当初客户端模拟的其实就是一致的，这种情况下，客户端就开开心心继续往前跑就好了。</p><p>只有在预测操作时，比如玩家一直在向前跑，但是服务器那里感知到另一个玩家对他释放了一个冰冻，将他顶在原地。这样，服务器回传给玩家的位置数据：他在某时刻停留在某地就和当初他自己预测的那个时刻的位置不同。产生这种预测失败后，客户端就需要自己调节。有 ECS 的帮助，状态回滚到发生分歧的版本，考虑到服务器回传的结果和新了解到的世界变化，重新将之后一段时间的操作重新作用到那一刻的状态上，做起来就相对简单了。</p><p>对于服务器来说，它默认客户端会持续不断的以固定周期向它推送新的操作。正如前面所说，服务器的时刻是有意比客户端延后的，这样，它并非立刻处理客户端来的输入，而是把输入先放在一个缓冲区里，然后按和客户端固定的周期 ( 60fps ) 从缓冲区里取。由于有这个小的缓冲区的存在，轻微的网络波动（每个网络包送达的路程时间不完全一致）是完全没有影响的。但如果网络不稳定，就会出现到时间了客户端的操作还没有送到。这个时候，服务器也会尝试预测一下客户端发生了什么。等真的操作包到达后，比对一下和自己的预测值有什么不同，基于过去那个产生分歧的预测产生的状态和实际上传的操作计算出下一个状态。</p><p>同时，这个时候服务器会意识到网络状态不好，它主动通知客户端说，网络不太对劲，这个时候的大家遵循的协议就比较有趣了。那就是客户端得到这个消息就开始做时间压缩，用更高的频率来跑游戏，从 60fps 提高到 65fps ，玩家会在感受到轻微的加速，结果就是客户端用更高的频率产生新的输入：从 16 ms 一次变成了 15.2 ms 一次。也就是说，短时间内，客户端的时刻更加领先服务器了，且越领先越多。这样，服务器的预读队列就能更多的接收到未来将发生的操作，遇到到点却不知道客户端输入的可能性就变少了。但是总流量并没有增加，因为假设一局游戏由一万个 tick 组成，无论客户端怎么压缩时间，提前时刻，总的数据还是一万个 tick 产生的操作，并没有变化。</p><p>一旦度过了网络不稳定期，服务器会通知客户端已经正常了，这个时候客户端知道自己压缩时间导致的领先时长，对应的膨胀放慢时间（降低向服务器发送操作的频率）让状态回到原点即可。</p><p>btw, 守望先锋 是基于 UDP 通讯的，从演讲介绍看，对于 UDP 可能丢包的这个问题，他们处理的简单粗暴：客户端每次都将没有经过服务器确认的包打包在一起发送。由于每个逻辑帧的操作很少，打包在一起也不会超过 MTU 限制。</p><p>ECS 在这个过程中真正发生威力的地方是在预测错误后纠正错误的阶段。一旦需要纠正过去发生的错误，就需要回滚、重新执行指令。移动、射击这些都属于常规的设定，比较容易做回滚重新执行；技能本身是基于暴雪开发的 Statescript 的，通过它来达到同样的效果。ECS 的威力在于，把这些元素用 Component 分离了，可以单独处理。</p><p>比如说射击命中判定，就是一个单独的系统，它基于被判定对象都有一个叫做 ModifyHealthQueue 的组件。这个组件里记录的是 Entity 身上收到的所有伤害和治疗效果。这个组件可以用于 Entity 的筛选器，没有这个组件的对象不会受到伤害，也就不需要参与命中判定。真正影响命中判定的是 MovementState 组件，它也参与了命中判定这个系统的筛选，并真正参与了运算。命中判定在查询了敌对关系后从 MovementState 中获取应该比对的对象的位置，来预测它是否被命中（可能需要播放对应的动画）。但是伤害计算，也就是 ModifyHealthQueue 里的数据是只能在服务器填写并推送给客户端的。</p><p>MovementState 会因为需要纠正错误预测而被回退，同时还有一些非 MovementState 的状态也会回退，比如门的状态、平台的状态等等。这个回退是 Utility 函数的行为，它可能会影响受击的表现，而受伤则是另一种固定行为（服务器确定的推送）的后果。他们发生在 Entity 的不同组件切片上，就可以正交分离。</p><p>射击预测和纠正可以利用对象的活动区域来减少判定计算量。如果能总是计算保持当前对象在过去一段时间的最大移动范围（即过去一段时间的包围盒的并集），那么当需要做一个之前发生的射击命中判定时，就只需要把射击弹道和当前所有对象的检测区域比较，只有相交才做进一步检测：回退相关对象到射击发生的时刻，做严格的命中校验。如果当初预测的命中结果和现在核验的一致就无所谓了，不需要修正结果（如果命中了，具体打中在哪不重要；如果未命中，也不管子弹射到哪里去了）。</p><p>如果 ping 值很高，客户端做命中预测往往是没有什么意义的，徒增计算量。所以在 Ping 超过 220ms 后，客户端就不再提前预测命中事件，直接等服务器回传。</p><p>ECS 框架在这件事上可以做到只去回滚和重算相关的 Component ，一个 System 知道哪些 Entity 才是它真正关心的，该怎么回退它所关心的东西。这样开发的复杂度就减少了。游戏本身是复杂的，但是和网络同步相关的影响到游戏业务的 System 却很少，而且参与的 Component 几乎都是只读的。这样我们就尽可能的把这个复杂的问题和引擎其它部分解耦。</p><blockquote><p>ECS 是个不错的框架，但是需要遵循一定的规范才能起到他应有的效果：减少大量系统间的耦合度。但并非所有的问题都适合遵循 ECS 的规范来开发，尤其是一些旧有的模块，很难做到把数据结构按 Component 得规范暴露出来，并把状态改变的方法集成到独立的 System 中去。这个时候就应该做一些封装的工作。比如说有些系统原本就利用了多线程模型作并行优化，所以我们需要把这些已经做好的工作隔离在 ECS 框架之外，仅仅暴露一些接口和 ECS 框架对接。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity 编辑器扩展</title>
      <link href="/2018/10/02/dunity-Custom-Editor/"/>
      <url>/2018/10/02/dunity-Custom-Editor/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C#反射和特性</title>
      <link href="/2018/10/02/dcs-Reflection-Attribute/"/>
      <url>/2018/10/02/dcs-Reflection-Attribute/</url>
      
        <content type="html"><![CDATA[<p><ruby><code>反射</code><rp>(</rp><rt>Reflection</rt><rp>)</rp></ruby>可以理解为<font color="red">镜像</font>或者<font color="red">映像</font>。</p><ul><li>反射可以在不知道类型或者用new操作符进行实例化的情况下创造出一样的目标对象，并且还能够访问该对象中的内部成员，因此反射的耦合几乎可以小到忽略不计。</li><li>当程序的某些逻辑只有处在运行状态中，且用户进行交互时才能确定的情况下，程序员就要对用户行为进行枚举，这样就容易写出大量的<code>if-else</code>，从而造成代码的臃肿和难以维护，还容易漏掉用户行为。<a id="more"></a></li></ul><blockquote><p>这时我们就可以用到反射，不过需要注意的是反射毕竟是动态的，所以他需要在内存中拿到对象的描述，和对象绑定的类型的描述再用这些描述来创建对象，所以会对程序性能有一定的影响，因此要注意不要盲目或过多的在程序里使用反射机制。</p></blockquote><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><ruby>依赖注入<rp>(</rp><rt>Dependency Injection</rt><rp>)</rp></ruby></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> 语法学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shader渲染流水线</title>
      <link href="/2018/09/29/dshader-rendering-pipeline/"/>
      <url>/2018/09/29/dshader-rendering-pipeline/</url>
      
        <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><h3 id="什么是流水线"><a href="#什么是流水线" class="headerlink" title="什么是流水线"></a>什么是流水线</h3><ul><li>一个产品拆分成多个部分，每个部分由专人制作。<ul><li>在流水线中决定最后生产速度的时间由最慢的那道工序(<ruby>瓶颈<rp>(</rp><rt>bottleneck</rt><rp>)</rp></ruby>)所决定。</li></ul></li></ul><blockquote><p>因此在理想情况下把一个生产流程分为<code>N</code>个步骤，且每个步骤花费的时间相同的话会使得整个流程速度提高<code>N</code>倍<br><a id="more"></a></p></blockquote><h3 id="什么是渲染流水线"><a href="#什么是渲染流水线" class="headerlink" title="什么是渲染流水线"></a>什么是渲染流水线</h3>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo 建站资料汇总</title>
      <link href="/2018/09/26/hexo-build-data-summary/"/>
      <url>/2018/09/26/hexo-build-data-summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>live2dCDN 以以下链接为参考做修改即可<br><a href="https://cdn.jsdelivr.net/npm/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json" target="_blank" rel="noopener">https://cdn.jsdelivr.net/npm/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json</a> </p></blockquote><a id="more"></a><h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><ol><li><a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">hexo从零开始到搭建完整</a></li><li><a href="https://www.jsdelivr.com/?query=live2d" target="_blank" rel="noopener">live2dCDN链接</a></li><li><a href="https://github.com/summerscar/live2dDemo" target="_blank" rel="noopener">Live2dDemo</a></li><li><a href="https://www.yanjiayu.cn/posts/ff508987.html" target="_blank" rel="noopener">Hexo 博客利用 live2d 插件放置一个萌萌哒看板娘</a></li><li><a href="https://yleao.coding.me/2018/0805/hexo%E4%B8%8A%E7%9A%84live2d%E5%BA%94%E7%94%A8.html" target="_blank" rel="noopener">hexo上的live2d应用</a></li><li><a href="http://summerscar.me/live2dDemo/" target="_blank" rel="noopener">配合上面的Live2d预览</a></li><li><a href="http://xiaweizi.cn/article/31905/#comments" target="_blank" rel="noopener">hexo 博客小功能添加-评论、相册、字数统计</a></li><li><a href="https://blog.csdn.net/stven_king/article/details/78357753?locationNum=3&amp;fps=1" target="_blank" rel="noopener">Hexo博客yelee主题添加Gitment评论系统</a></li><li><a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="noopener">Gitment：使用 GitHub Issues 搭建评论系统</a></li><li><a href="https://www.xxwhite.com/2017/Valine.html" target="_blank" rel="noopener">加个Valine评论系统</a></li><li><a href="http://moxfive.xyz/2016/01/02/hexo-comments/" target="_blank" rel="noopener">为 Hexo 主题添加评论模块 — Disqus, 多说, 友言</a></li><li><a href="http://jumpbyte.cn/2016/07/02/use-and-install-prettify/" target="_blank" rel="noopener">代码高亮</a></li><li><a href="http://www.hiekay.com/categories/hexo/" target="_blank" rel="noopener">valine评论，计数，萌宠，版权，打赏，搭建等</a></li><li><a href="http://moxfive.xyz/2016/01/10/hexo-post-version-control/" target="_blank" rel="noopener">关联 GitHub, 让 Hexo 支持查看文章更新历史</a></li><li><a href="http://xiaweizi.cn/article/39434/" target="_blank" rel="noopener">博客搭建</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo 页面自动刷新与移动端调试</title>
      <link href="/2018/09/17/hexo-browsersync/"/>
      <url>/2018/09/17/hexo-browsersync/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red">转载自</font><a href="http://moxfive.xyz/2016/03/27/hexo-browsersync/" target="_blank" rel="noopener">moxfive.xyz</a></p></blockquote><p></p><h2 id="intro">前言</h2>经常本地调试 Hexo 主题, 如果有工具能监视文件更改幷自动刷新页面，那一定能提高不少效率，<a href="http://www.browsersync.cn/" target="_blank" rel="noopener">Browsersync</a> 就是这样一款浏览器同步测试工具。<p></p><a id="more"></a><p><img src="https://i.loli.net/2018/09/29/5baea70971405.gif" alt="browser-sync"></p><h2 id="自动刷新"><a href="#自动刷新" class="headerlink" title="自动刷新"></a>自动刷新</h2><h3 id="安装-Browsersync"><a href="#安装-Browsersync" class="headerlink" title="安装 Browsersync"></a>安装 Browsersync</h3><ul><li>Browsersync 依赖包较多，Mac 和 Linux 中建议加上 <code>sudo</code> 避免安装时因权限不足而报错</li></ul><pre><code class="bash">npm install -g browser-sync</code></pre><ul><li>安装结束后执行下面命令，能显示对应版本则表示安装成功</li></ul><pre><code class="bash">browser-sync --version</code></pre><blockquote><p>如果显示无此命令，请尝试使用 <a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝 NPM 镜像</a>，或者全局科学上网后再安装</p></blockquote><h3 id="安装-Hexo-端插件"><a href="#安装-Hexo-端插件" class="headerlink" title="安装 Hexo 端插件"></a>安装 Hexo 端插件</h3><ul><li>要把 Browsersync 应用到 Hexo 上，还需要安装一个小插件 <a href="https://github.com/hexojs/hexo-browsersync" target="_blank" rel="noopener">hexo-browsersync</a> 。命令行中进入 Hexo 根目录，执行以下命令:</li></ul><pre><code class="bash">npm install hexo-browsersync --save</code></pre><ul><li>安装后像往常一样执行 <code>hexo s</code> 开启本地服务器，当相关文件被修改或者保存时，关联的浏览器页面会自带刷新</li></ul><h3 id="一些不足"><a href="#一些不足" class="headerlink" title="一些不足"></a>一些不足</h3><ul><li>变动后将重新加载整个页面，不能局部刷新；</li><li>使用 Hexo 自带服务器时，无法在移动端调试；</li><li>偶尔会报错，需要多保存几次；</li></ul><h2 id="移动端调试"><a href="#移动端调试" class="headerlink" title="移动端调试"></a>移动端调试</h2><p>如果只是为了自动刷新页面，或许使用 LiveReload 就够了。Browsersync 真正强大之处在于其多设备调试功能，局域网设备访问同一网址，页面同步变动。</p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><ul><li>要在移动端调试，需要先生成 Hexo 站点的静态文件</li></ul><pre><code class="bash">hexo g</code></pre><h3 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h3><ul><li>命令行进入静态文件所在的文件夹，默认为 Hexo 根目录下的 <code>public</code>，然后执行以下命令：</li></ul><pre><code class="bash">browser-sync start --server --files &quot;css/*.css, *.html&quot;</code></pre><ul><li>输入完毕按回车，会自动打开网站首页</li><li>更多命令行用法请参考 <a href="http://www.browsersync.cn/docs/command-line/" target="_blank" rel="noopener">官方文档</a></li></ul><h3 id="局域网访问"><a href="#局域网访问" class="headerlink" title="局域网访问"></a>局域网访问</h3><ul><li>回到命令行窗口，External 那行的 IP 地址就是局域网地址，打开你的手机平板访问即可，各种操作和文件修改都会同步变动，调试极为便利</li></ul><p><img src="https://i.loli.net/2018/09/29/5baea7097a0fa.gif" alt="browsersync-2"></p><blockquote><p>此种方式不是直接修改主题源文件，所以平时一般使用 Hexo 本地服务修改样式，有需要时再生成静态文件在移动端测试页面效果</p></blockquote><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li>Browsersync: <a href="http://www.browsersync.cn/" target="_blank" rel="noopener">http://www.browsersync.cn/</a></li><li>hexo-browsersync: <a href="https://github.com/hexojs/hexo-browsersync" target="_blank" rel="noopener">https://github.com/hexojs/hexo-browsersync</a></li><li>淘宝 NPM 镜像: <a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo文章置顶的方法</title>
      <link href="/2018/09/17/hexo-article-set-top/"/>
      <url>/2018/09/17/hexo-article-set-top/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red">转载自</font><a href="https://liuxuewne.github.io/2018/01/29/Hexo-bs-articleTop/" target="_blank" rel="noopener">liuxuewne.github.io</a></p></blockquote><p>Hexo 默认只提供了按发布日期的降序来排序，通过在 Hexo github 的 issue 里找到了解决办法，原理：在 Hexo 生成首页 HTML 时，将 top 值高的文章排在前面，达到置顶功能，以下解决方法在Hexo 3.3.6 上修改相关文件。<br><a id="more"></a></p><h3 id="修改-Hexo-文件夹下的-node-modules-hexo-generator-index-lib-generator-js文件"><a href="#修改-Hexo-文件夹下的-node-modules-hexo-generator-index-lib-generator-js文件" class="headerlink" title="修改 Hexo 文件夹下的 node_modules/hexo-generator-index/lib/generator.js文件"></a>修改 Hexo 文件夹下的 <code>node_modules/hexo-generator-index/lib/generator.js</code>文件</h3><p>找到该文件后，添加以下代码：</p><pre><code class="JavaScript">posts.data = posts.data.sort(function(first, second) {   if (first.top &amp;&amp; second.top) { // 两篇文章top都有定义        return first.top == second.top ? second.date - first.date : second.top - first.top //若top值一样则按照文章日期降序排, 否则按照top值降序排    } else if (first.top &amp;&amp; !second.top) { // 以下是只有一篇文章top有定义，将有top的排在前面        return -1;    } else if (!first.top &amp;&amp; second.top) {        return 1;    } else {        return second.date - first.date;  // 都没定义top，按照文章日期降序排    }    });</code></pre><p>更改后的完整代码如下：</p><pre><code class="JavaScript">&#39;use strict&#39;;var pagination = require(&#39;hexo-pagination&#39;);module.exports = function(locals) {  var config = this.config;  var posts = locals.posts.sort(config.index_generator.order_by);    posts.data = posts.data.sort(function(first, second) {        if (first.top &amp;&amp; second.top) { // 两篇文章top都有定义            return first.top == second.top ? second.date - first.date : second.top - first.top //若top值一样则按照文章日期降序排, 否则按照top值降序排        } else if (first.top &amp;&amp; !second.top) { // 以下是只有一篇文章top有定义，将有top的排在前面            return -1;        } else if (!first.top &amp;&amp; second.top) {            return 1;        } else {            return second.date - first.date;  // 都没定义top，按照文章日期降序排        }    });  var paginationDir = config.pagination_dir || &#39;page&#39;;  var path = config.index_generator.path || &#39;&#39;;  return pagination(path, posts, {    perPage: config.index_generator.per_page,    layout: [&#39;index&#39;, &#39;archive&#39;],    format: paginationDir + &#39;/%d/&#39;,    data: {      __index: true    }  });};</code></pre><p>不同版本的 Hexo 代码可能有些区别；添加的代码跟版本无关。</p><h3 id="在需要置顶的文章的-front-matter-中添加-top-值"><a href="#在需要置顶的文章的-front-matter-中添加-top-值" class="headerlink" title="在需要置顶的文章的 front-matter 中添加 top 值"></a>在需要置顶的文章的 front-matter 中添加 top 值</h3><p>top 值越大，文章越靠前，举例如下：</p><pre><code class="Markdown">title: miho-主题安装和配置详情date: 2017-08-01categories: 开源项目author: MinHowtags:    - 博客    - 开源项目cover_picture: https://cloud.minhow.com/images/miho/theme/github-second.jpgtop: 1</code></pre><p><a href="https://blog.minhow.com/2017/08/20/hexo/article-top/" target="_blank" rel="noopener">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo 最常用的几个命令</title>
      <link href="/2018/09/17/hexo-common-commands/"/>
      <url>/2018/09/17/hexo-common-commands/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red">转载自</font><a href="http://moxfive.xyz/2015/12/21/common-hexo-commands/" target="_blank" rel="noopener">moxfive.xyz</a></p></blockquote><style>    .article-entry h2 {        border-bottom: none;    }</style><p>　　Hexo 约有二十个命令，但普通用户经常使用的大概只有下列几个: </p><a id="more"></a><h2 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h2><pre><code>hexo s</code></pre><p>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><ul><li><code>hexo s</code> 是 <code>hexo server</code> 的缩写，命令效果一致；</li><li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</li><li>对 Hexo 根目录 <code>_config.yml</code> 的修改，需要重启本地服务器后才能预览效果。</li></ul><h2 id="hexo-n"><a href="#hexo-n" class="headerlink" title="hexo n"></a>hexo n</h2><pre><code>hexo n &quot;学习笔记  六&quot;</code></pre><p>新建一篇标题为 <code>学习笔记  六</code> 的文章，因为标题里有空格，所以加上了引号。</p><ul><li>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些；</li><li><code>hexo n</code> 是 <code>hexo new</code> 的缩写，命令效果一致。</li></ul><h2 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h2><pre><code>hexo d</code></pre><p>自动生成网站静态文件，并部署到设定的仓库。</p><ul><li><code>hexo d</code> 是 <code>hexo deploy</code> 的缩写，命令效果一致。</li></ul><h2 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h2><pre><code>hexo clean</code></pre><p>清除缓存文件 <code>db.json</code> 和已生成的静态文件 <code>public</code>。</p><ul><li>网站显示异常时可以执行这条命令试试。</li></ul><h2 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h2><pre><code>hexo g</code></pre><p>生成网站静态文件到默认设置的 <code>public</code> 文件夹。</p><ul><li>便于查看网站生成的静态文件或者手动部署网站；</li><li>如果使用自动部署，不需要先执行该命令；</li><li><code>hexo g</code> 是 <code>hexo generate</code> 的缩写，命令效果一致。</li></ul><h2 id="hexo-n-page"><a href="#hexo-n-page" class="headerlink" title="hexo n page"></a>hexo n page</h2><pre><code>hexo n page aboutme</code></pre><p>新建一个标题为 <code>aboutme</code> 的页面，默认链接地址为 <code>主页地址/aboutme/</code></p><ul><li>标题可以为中文，但一般习惯用英文；</li><li>页面标题和文章一样可以随意修改；</li><li>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</li></ul><h2 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h2><pre><code>hexo clean &amp;&amp; hexo shexo clean &amp;&amp; hexo d</code></pre><p>可以用输入法等软件为这些命令设置快捷键，方便调用。</p><h2 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h2><ul><li>以上命令使用基于 Hexo 3.1.1 版本；</li><li>需要删掉用命令新建的文章或页面时，只需要进入 Hexo 根目录下的 <code>source</code> 文件夹，删除对应文件或文件夹即可；</li><li>更多命令用法请查询 <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">官方文档</a>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MiHo-主题安装和配置详情</title>
      <link href="/2018/09/17/hexo-installation-configuration/"/>
      <url>/2018/09/17/hexo-installation-configuration/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red">转载自</font><a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">moxfive.xyz</a></p></blockquote><a id="more"></a><p><img src="http://oerolc7og.bkt.clouddn.com/images/miho/theme/github.jpg" alt="miho"></p><h3 id="一-主题简介主题简介主题简介主题简介"><a href="#一-主题简介主题简介主题简介主题简介" class="headerlink" title="一. 主题简介主题简介主题简介主题简介"></a>一. 主题简介主题简介主题简介主题简介</h3><p>&emsp;&emsp;MiHo 是一款单栏响应式的<a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>主题；基于 Hexo 3.0+ 制作，兼容移动端浏览；主题的代码托管在<a href="https://github.com/WongMinHo/hexo-theme-miho" target="_blank" rel="noopener">GitHub</a>上，<br>欢迎Star和Fork；如遇到问题或发表建议，可以提<a href="https://github.com/WongMinHo/hexo-theme-miho/issues" target="_blank" rel="noopener">Issues</a>，也可以在博客中留言给我，另外,喜欢的话不妨给个 Star。</p><h3 id="二-安装"><a href="#二-安装" class="headerlink" title="二. 安装"></a>二. 安装</h3><h4 id="2-1-安装主题"><a href="#2-1-安装主题" class="headerlink" title="2.1 安装主题"></a>2.1 安装主题</h4><pre><code class="bash">$ git clone https://github.com/WongMinHo/hexo-theme-miho.git themes/miho</code></pre><p>MiHo 主题需要Hexo 3.0或以上版本，请先升级。</p><h4 id="2-2-更新"><a href="#2-2-更新" class="headerlink" title="2.2 更新"></a>2.2 更新</h4><pre><code class="bash">cd themes/mihogit pull</code></pre><h4 id="2-3-依赖安装"><a href="#2-3-依赖安装" class="headerlink" title="2.3 依赖安装"></a>2.3 依赖安装</h4><p>如下依赖如果已经安装，请看配置介绍。</p><h5 id="Json-content"><a href="#Json-content" class="headerlink" title="Json-content"></a>Json-content</h5><p>生成站点文章静态数据，用于站内搜索。</p><pre><code class="bash">npm install hexo-generator-json-content --save</code></pre><h3 id="三-站点配置"><a href="#三-站点配置" class="headerlink" title="三. 站点配置"></a>三. 站点配置</h3><p>站点配置文件<code>_config.yml</code>在hexo根目录下。</p><h4 id="3-1-启用主题"><a href="#3-1-启用主题" class="headerlink" title="3.1 启用主题"></a>3.1 启用主题</h4><pre><code class="bash">`theme: miho`</code></pre><h4 id="3-2-网站基本配置"><a href="#3-2-网站基本配置" class="headerlink" title="3.2 网站基本配置"></a>3.2 网站基本配置</h4><p>以下配置是站点的全局配置，更多配置，请<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">查看</a></p><pre><code class="bash">title: MinHow&#39;s Blogsubtitle: 网站副标题description: 专注 WEB 开发的技术博客author: MinHowlanguage: 网站使用的语言timezone: 网站时区</code></pre><h4 id="3-3-jsonContent配置"><a href="#3-3-jsonContent配置" class="headerlink" title="3.3 jsonContent配置"></a>3.3 jsonContent配置</h4><p>详细的配置请查看<a href="https://github.com/alexbruno/hexo-generator-json-content" target="_blank" rel="noopener">hexo-generator-json-content</a></p><pre><code class="bash">jsonContent:  meta: false  pages: false  posts:    title: true    date: true    path: true    text: false    raw: false    content: false    slug: false    updated: false    comments: false    link: false    permalink: false    excerpt: false    categories: false    tags: false</code></pre><h3 id="四-主题配置"><a href="#四-主题配置" class="headerlink" title="四. 主题配置"></a>四. 主题配置</h3><p>编辑主题配置文件，<code>themes/miho/_config.yml</code>。</p><h4 id="4-1-属性"><a href="#4-1-属性" class="headerlink" title="4.1 属性"></a>4.1 属性</h4><p>下面将介绍几个比较重要的配置。</p><pre><code class="bash"># hexo-theme-miho# https://github.com/wongminho/hexo-theme-miho# Favicon of your site | 网站iconfavicon: /favicon.ico# Header# Keywords of your site | 网站关键字keywords: MinHow,MinHow&#39;s Blog# Head headline | 头部标题header_title: MinHow&#39;s Blog# Head description | 头部描述header_description: 一个专注 WEB 开发的技术博客# Link to your logo | logo地址logo: images/logo.png# Link to your banner_img | 首页banner图地址banner_img: images/banner.jpg# Menu setting | 菜单设置#  name:                  Font Awesome icon | Font Awesome 图标#    title: Home          Title | 标题#    url: //minhow.com    Url, absolute or relative path | 链接，绝对或相对路径#    target: true         Whether to jump out | 是否跳出menu:  home:    title: Home    url: /    target: false  archive:    title: Archives    url: /archives    target: false  user:    title: About    url: /about    target: false# Social setting, use to display social information | 社交设置，用来展示社交信息#  name:                  Font Awesome icon | Font Awesome 图标#    title: Home          Icon title | 图标标题#    url: //minhow.com    Url, absolute or relative path | 链接，绝对或相对路径#    target: true         Whether to jump out | 是否跳出social:  home:    title: MinHow    url: //minhow.com    target: true  github:    title: Github    url: //github.com/wongminho    target: true  weibo:    title: Weibo    url: //weibo.com/WongMinHo    target: true  twitter:    title: Twitter    url: //twitter.com/huangminhow    target: true  #qq:  #weixin:  #snapchat:  #telegram:  #mail:  #facebook:  #google:  #linkedin:# Content# Excerpt length | 摘录长度excerpt_length: 190# Excerpt link | 摘录链接excerpt_link: more&gt;&gt;# New window open link | 新窗口打开文章open_new_link: false# Article default cover picture，size：350*150 | 文章默认封面图，尺寸：350*150cover_picture: images/banner.jpg# Open background particles | 开启背景粒子open_bg_particle: true# Open animation in homepage and head | 开启主页及头部动画open_animation: true# Article# Open toc | 是否开启toctoc: true# Open share | 是否开启分享share: true# Style customization | 样式定制style:  # Main color tone | 主色调  main_color: &#39;#0cc&#39;# Comments | 评论# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false# Analytics | 分析# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google analytics | google分析google_analytics: false# Footer# Access statistics | “不蒜子”访问量统计access_counter:  on: true  site_uv: 总访客数：  site_pv: 总访问量：# Copyright Information | 版权信息copyright: 2017 MinHow</code></pre><h4 id="4-2-文章封面图"><a href="#4-2-文章封面图" class="headerlink" title="4.2 文章封面图"></a>4.2 文章封面图</h4><p>文章默认封面图，尺寸：350*150，当文章基本配置没有<code>cover_picture</code>时才显示。</p><pre><code class="bash">cover_picture: images/banner.jpg</code></pre><h4 id="4-3-开启背景粒子"><a href="#4-3-开启背景粒子" class="headerlink" title="4.3 开启背景粒子"></a>4.3 开启背景粒子</h4><p>是否开启背景粒子。</p><pre><code class="bash">open_bg_particle: true</code></pre><h4 id="4-4-开启主页及头部动画"><a href="#4-4-开启主页及头部动画" class="headerlink" title="4.4 开启主页及头部动画"></a>4.4 开启主页及头部动画</h4><p>是否开启主页及头部动画。</p><pre><code>open_animation: true</code></pre><h4 id="4-5-评论"><a href="#4-5-评论" class="headerlink" title="4.5 评论"></a>4.5 评论</h4><p>支持畅言、disqus。</p><pre><code class="bash"># 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false</code></pre><h4 id="4-6-数据统计"><a href="#4-6-数据统计" class="headerlink" title="4.6 数据统计"></a>4.6 数据统计</h4><p>支持站长、百度、google三种数据统计，正确填写配置信息即可。</p><pre><code class="bash"># 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google分析google_analytics: false</code></pre><h4 id="4-7-文章基本配置"><a href="#4-7-文章基本配置" class="headerlink" title="4.7 文章基本配置"></a>4.7 文章基本配置</h4><pre><code class="bash">---title: Hello Worlddate: 2017-06-18categories: Firstauthor: MinHowtags:    - First    - Secondcover_picture: /images/banner.jpg--- MinHow-This is a summary&lt;!-- more --&gt;</code></pre><blockquote><p>需要注意<code>tags</code>和摘要的写法，不然首页不能正确显示标签和摘要；<br>需要注意<code>tags</code>和摘要的写法，不然首页不能正确显示标签和摘要；</p></blockquote><p>说明：</p><ul><li>需要注意<code>tags</code>和摘要的写法，不然首页不能正确显示标签和摘要；</li><li><code>cover_picture</code>文章封面图，不填默认显示<code>_config.yml</code>配置的图片。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于 Yelee 主题背景图的压缩与优化</title>
      <link href="/2018/09/17/hexo-image-compression/"/>
      <url>/2018/09/17/hexo-image-compression/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red">转载自</font><a href="http://moxfive.xyz/2016/05/17/image-compression/" target="_blank" rel="noopener">moxfive.xyz</a></p></blockquote><p>　　目前主题里可以使用多张随机大图作背景，如果不做好图片压缩和优化，可能会严重影响网站流畅性。下面简单介绍两种比较便捷的优化方案。</p><a id="more"></a><h2 id="优化说明"><a href="#优化说明" class="headerlink" title="优化说明"></a>优化说明</h2><ul><li>请使用 <code>jpg</code> 后缀名的背景图片；</li><li>如果可以，使用 <code>渐进式JPEG</code>，让图片加载时逐渐清晰；</li><li>将图片品质尽量调低，一般可以压缩到几十kb（背景图半透明显示，因此细节并不重要）；<blockquote><p>下图1 为目前主题自带背景图的分辨率和文件大小展示，图2 为渐进式图片加载示例</p></blockquote></li></ul><p><img src="https://i.loli.net/2018/09/29/5baeffa8c8302.png" alt="Yelee Background info."> <img src="https://i.loli.net/2018/09/29/5baeffb01514e.gif" alt="Progressive JPEGs"></p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="PhotoShop"><a href="#PhotoShop" class="headerlink" title="PhotoShop"></a>PhotoShop</h3><ul><li>电脑上如果装有 PhotoShop, 那用其来优化图片真是再好不过了</li><li>PS 打开图片 → 文件 → 存储为 Web 所用格式 → JPEG 格式，品质 0，勾选 <code>连续</code> （渐进式），最后存储，这样一张高压缩渐进式的 JPG 背景图就做好了</li></ul><p><img src="https://i.loli.net/2018/09/29/5baeffe583b5e.png" alt="image Compression by PhotoShop"></p><h3 id="智图"><a href="#智图" class="headerlink" title="智图"></a>智图</h3><ul><li><a href="http://zhitu.isux.us/" target="_blank" rel="noopener">智图</a> 是腾讯 ISUX 出品的在线图片优化工具，可以方便的对比优化前后的图片，同时可以自行调节图片品质，除了不能设置 <code>渐进式JPEG</code> , 其他基本满足背景图优化需要</li><li>进入网站后按提示上传图片，再调低图片品质，之后下载图片即可<blockquote><p>因为主题背景图为 <code>jpg</code> 格式，其他格式请转为 <code>jpg</code> 再上传到该网站优化。转换格式方法很多，比如用 Windows 自带的画图打开图片然后另存为 jpg</p></blockquote></li></ul><p><img src="https://i.loli.net/2018/09/29/5baeffe5874a5.png" alt="智图"></p><h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><ul><li>原图为 420kb，智图选择最低品质(10)后约为 129kb；</li><li>PhotoShop 选择品质 0，可以压缩到 62k，同时可以设为 <code>渐进式JPEG</code>；</li><li>因此，有条件的话更推荐使用 PS 压缩背景图。</li></ul><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><strong>智图</strong>: <a href="http://zhitu.isux.us/" target="_blank" rel="noopener">http://zhitu.isux.us/</a></li><li><strong>TinyPNG</strong>: <a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></li><li><strong><em>渐进式 jpeg(progressive jpeg) 图片及其相关</em></strong> by <strong>张鑫旭</strong> on <code>2013/01/07</code>: <a href="http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/</a></li><li><strong>呆毛王示例壁纸下载</strong>: <a href="http://moxfive.xyz/resources/saber.jpg" target="_blank" rel="noopener">http://moxfive.xyz/resources/saber.jpg</a></li><li><strong>最人性化的壁纸网站</strong>: <a href="http://www.wallpaperpcmobile.com/" target="_blank" rel="noopener">http://www.wallpaperpcmobile.com/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关联 GitHub, 让 Hexo 支持查看文章更新历史</title>
      <link href="/2018/09/17/hexo-post-version-control/"/>
      <url>/2018/09/17/hexo-post-version-control/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red">转载自</font><a href="http://moxfive.xyz/2016/01/10/hexo-post-version-control/" target="_blank" rel="noopener">moxfive.xyz</a></p></blockquote><p></p><h2 id="intro">前言</h2>Hexo 的文章源文件就是一个个 Markdown 文本，自己一直把这些文件备份在 <a href="https://github.com/MOxFIVE/Markdown-Archives-Backup" target="_blank" rel="noopener">GitHub</a> 上。渐渐发觉，如果只把 GitHub 当作普通网盘，那真是有点大材小用了。于是稍作折腾，成功地把 GitHub 上的备份关联到主题中。现在，在文章文末版权区，可以很方便地跳转查看文章更新记录、历史版本以及下载源文件。<p></p><a id="more"></a><p><img src="https://i.loli.net/2018/09/29/5baefe8a15433.png" alt="version-control"></p><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><ul><li>为了便于文章识别和自动关联文件，文章 Markdown 的文件名应该符合规范。</li><li>建议使用 文章建立日期.固定链接 <code>YY-MM-DD.permalink.md</code> 的形式。</li><li>在文章 [Front-matter] 中设置固定链接 permalink，然后填写文件名，例如本文完整文件名为 <code>2016-01-10.hexo-post-version-control.md</code></li><li>为什么不使用文章标题作为文件名:<blockquote><p>一是因为标题偶尔会变动，修改相对麻烦；二是标题可能包含不能用作文件名的符号，导致关联出错。</p></blockquote></li></ul><h3 id="文件备份"><a href="#文件备份" class="headerlink" title="文件备份"></a>文件备份</h3><ul><li>把 <code>hexo/sources/_posts</code> 文件夹同步备份到你的 GitHub 上，不熟悉 Git 的可使用 GitHub Desktop 操作，具体方法自行搜索。</li></ul><h2 id="代码添加"><a href="#代码添加" class="headerlink" title="代码添加"></a>代码添加</h2><p>把下面 EJS 代码添加到主题文章模板合适位置中，<a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">Yelee</a> 主题是添加在文末版权区中。参考备份文件在 Github 的链接修改前半部分地址。</p><pre><code>&lt;% if (post.backup != false){ %&gt;    &lt;p&gt;        &lt;span&gt;更新历史:&lt;&#x2F;span&gt;&lt;i class=&quot;fa fa-github&quot;&gt;&lt;&#x2F;i&gt;        &lt;a href=&quot;&lt;文章 Blame 地址&gt;&#x2F;&lt;%= post.date.format(&quot;YYYY-MM-DD&quot;) %&gt;.&lt;%= post.slug %&gt;.md&quot; title=&quot;顺序查看文章各部分修改记录&quot; target = &quot;_blank&quot;&gt;Blame&lt;&#x2F;a&gt;,        &lt;a href=&quot;&lt;文章 History 地址&gt;&#x2F;&lt;%= post.date.format(&quot;YYYY-MM-DD&quot;) %&gt;.&lt;%= post.slug %&gt;.md&quot; title=&quot;查看文章有关更新记录&quot; target = &quot;_blank&quot;&gt;History&lt;&#x2F;a&gt;&lt;span class=&quot;raw&quot;&gt;文本模式:&lt;&#x2F;span&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;&#x2F;i&gt;        &lt;a href=&quot;&lt;文章 Raw 地址&gt;&#x2F;&lt;%= post.date.format(&quot;YYYY-MM-DD&quot;) %&gt;.&lt;%= post.slug %&gt;.md&quot; title=&quot;查看 &amp; 下载文章 Markdown 原始文本&quot; target = &quot;_blank&quot;&gt; .md Raw&lt;&#x2F;a&gt;    &lt;&#x2F;p&gt;&lt;% } %&gt;</code></pre><h2 id="代码简析"><a href="#代码简析" class="headerlink" title="代码简析"></a>代码简析</h2><pre><code class="erb">&lt;!-- 不设置 backup: false 则默认显示 --&gt;&lt;% if (post.backup != false){ %&gt;    &lt;p&gt;         &lt;span&gt;更新历史:&lt;/span&gt;&lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;        &lt;!-- 不同功能替换前面超链接即可，文件名不变 --&gt;        &lt;!-- 文件名生成: &lt;%= post.date.format(&quot;YYYY-MM-DD&quot;) %&gt;.&lt;%= post.slug %&gt; --&gt;        &lt;a href=&quot;&lt;文章 Blame 地址&gt;/&lt;%= post.date.format(&quot;YYYY-MM-DD&quot;) %&gt;.&lt;%= post.slug %&gt;.md&quot; title=&quot;顺序查看文章各部分修改记录&quot; target = &quot;_blank&quot;&gt;Blame&lt;/a&gt;,        &lt;a href=&quot;&lt;文章 History 地址&gt;/&lt;%= post.date.format(&quot;YYYY-MM-DD&quot;) %&gt;.&lt;%= post.slug %&gt;.md&quot; title=&quot;查看文章有关更新记录&quot; target = &quot;_blank&quot;&gt;History&lt;/a&gt;&lt;span class=&quot;raw&quot;&gt;文本模式:&lt;/span&gt;&lt;i class=&quot;fa fa-file-text-o&quot;&gt;&lt;/i&gt;        &lt;a href=&quot;&lt;文章 Raw 地址&gt;/&lt;%= post.date.format(&quot;YYYY-MM-DD&quot;) %&gt;.&lt;%= post.slug %&gt;.md&quot; title=&quot;查看 &amp; 下载文章 Markdown 原始文本&quot; target = &quot;_blank&quot;&gt; .md Raw&lt;/a&gt;    &lt;/p&gt;&lt;% } %&gt;</code></pre><h3 id="Blame"><a href="#Blame" class="headerlink" title="Blame"></a>Blame</h3><ul><li>顺序列出文章内容，左侧显示各部分 commit 信息，最后修改时间等。<br><img src="https://i.loli.net/2018/09/29/5baefed3e18fd.png" alt="Blame"></li></ul><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><ul><li>列出与该文件相关的更新记录 (commit)，按路径匹配。我一般直接就用提交时间作为 commit 信息了，想要更直观查看变动的可以在提交时书写更完善的 commit 信息。</li></ul><p><img src="https://i.loli.net/2018/09/29/5baeff03860cf.png" alt="History"></p><h3 id="md-Raw"><a href="#md-Raw" class="headerlink" title=".md Raw"></a>.md Raw</h3><ul><li>在线查看或者直接下载文章原始 Markdown 文本。<br><img src="https://i.loli.net/2018/09/29/5baeff415c48f.png" alt="Raw"></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><ul><li>这是半自动的版本控制，需要手动把文章同步备份到 GitHub；</li><li>代码部分的变动基于 <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">Yelee</a> 主题，其它主题用户可以参考 <a href="/2015/10/25/hexo-tag-cloud/">另一篇文章</a> 的方法，自行添加代码到合适位置；</li><li>小图标来自 Font Awesome，需主题支持才会正常显示；</li><li>本文不详解 Hexo 基础知识，有设置项不理解的请先阅读 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方帮助文档</a>。</li></ul></blockquote><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><strong>GitHub Desktop</strong>: <a href="https://desktop.github.com/" target="_blank" rel="noopener">https://desktop.github.com/</a></li><li><strong>Font Awesome</strong>: <a href="http://fontawesome.io/" target="_blank" rel="noopener">http://fontawesome.io/</a></li><li><strong>Hexo 使用文档</strong>: <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li><li><strong><em>Hexo 文章版本控制</em></strong>  by <strong>MOxFIVE</strong> on <code>2016/01/10</code>: <a href="https://github.com/MOxFIVE/M-Hexo-Blog/commit/d8a4942dab23920837cc70249c31697d36e49235" target="_blank" rel="noopener">https://github.com/MOxFIVE/M-Hexo-Blog/commit/d8a4942dab23920837cc70249c31697d36e49235</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2018/09/17/syntax-markdown/"/>
      <url>/2018/09/17/syntax-markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote><p>书写Markdown时可以嵌套html语法来实现一些原生Markdown不支持的效果<br><a id="more"></a></p></blockquote><h3 id="定义一个标题"><a href="#定义一个标题" class="headerlink" title="定义一个标题"></a>定义一个标题</h3><p>一个<code>#</code>为一级标题，两个<code>##</code>为二级标题，以此类推，Markdown最多支持<font color="red">6</font>级标题。</p><ul><li>可以复制以下代码试验<pre><code class="Markdown{.line-numbers}"># 这是一级标题## 这是二级标题### 这是三级标题#### 是四级标题##### 这是五级标题###### 这是六级标题</code></pre></li><li>扩展语法，在文字下面加上两个以上的<code>=</code>或<code>-</code>。</li></ul><pre><code class="markdown{.line-numbers}">一级标题=======二级标题-------</code></pre><h3 id="字符样式"><a href="#字符样式" class="headerlink" title="字符样式"></a>字符样式</h3><ol><li><em>斜体</em><br><code>*斜体*</code>和<code>_斜体_</code>都能实现斜体效果</li><li><strong>粗体</strong><br><code>**粗体**</code>和<code>__粗体__</code>都能实现粗体效果</li><li><del>删除线</del><br><code>~~删除线~~</code></li><li><del><strong><em>组合体</em></strong></del><br><code>~~***组合体***~~</code></li></ol><h3 id="注音"><a href="#注音" class="headerlink" title="注音"></a>注音</h3><blockquote><p>此为vscode添加的插件<code>Markdown Paste</code>的功能<br>选中要标注的文字按快捷键<code>Ctrl+Alt+T</code>即可开始注音</p></blockquote><p><ruby>聪明<rp>(</rp><rt>pronunciation</rt><rp>)</rp></ruby></p><pre><code>&lt;ruby&gt;聪明&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;pronunciation&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;</code></pre><p><a href="https://github.com/telesoho/vscode-markdown-paste-image" target="_blank" rel="noopener">插件地址</a></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li>Item1</li><li>Item2<ul><li>Item1</li><li>Item2<ul><li>Item1</li></ul></li></ul></li><li>Item3</li></ul><p>无序列表中可以用字符<code>*</code>、<code>+</code>和<code>-</code>来做标记，一个制表符或<font color="red">4</font>个空格来确定列表间的母子关系。</p><pre><code class="markdown{.line-numbers}">* Item1* Item2    * Item1    * Item2        * Item1* Item3</code></pre><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><ol start="2"><li>Item1</li><li>Item2</li><li>Item3</li></ol><p>有序列表和无序列表不同之处在于有序列表会按第一位的数值进行自动的编号排序。</p><pre><code class="markdown{.line-numbers}">2. Item11. Item210. Item3</code></pre><h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><ul><li style="list-style: none"><input type="checkbox" checked> 写markdown语法笔记</li><li style="list-style: none"><input type="checkbox"> 睡觉</li></ul><pre><code class="markdown">- [x] 写markdown语法笔记- [ ] 睡觉</code></pre><h3 id="添加链接"><a href="#添加链接" class="headerlink" title="添加链接"></a>添加链接</h3><ul><li>直接引用<br>  <a href="mailto:123@qq.com" target="_blank" rel="noopener">123@qq.com</a><br>  <a href="https://i.loli.net/2018/09/16/5b9dbce0bac35.png" target="_blank" rel="noopener">https://i.loli.net/2018/09/16/5b9dbce0bac35.png</a><br>  <a href="mailto:&#x31;&#50;&#x33;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#x31;&#50;&#x33;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;</a><br>  <a href="https://i.loli.net/2018/09/16/5b9dbce0bac35.png" target="_blank" rel="noopener">https://i.loli.net/2018/09/16/5b9dbce0bac35.png</a></li></ul><pre><code class="markdown{.line-numbers}">123@qq.comhttps://i.loli.net/2018/09/16/5b9dbce0bac35.png&lt;https://i.loli.net/2018/09/16/5b9dbce0bac35.png&gt;&lt;123@qq.com&gt;&lt;https://i.loli.net/2018/09/16/5b9dbce0bac35.png&gt;</code></pre><ul><li><p>超链接</p><ul><li>不带鼠标悬停Title链接<br>  <a href="https://i.loli.net/2018/09/16/5b9dbce0bac35.png" target="_blank" rel="noopener">测试链接1</a><pre><code class="markdown">  [测试链接1](https://i.loli.net/2018/09/16/5b9dbce0bac35.png)</code></pre></li><li><p>带鼠标悬停Title链接</p><blockquote><p>邮箱链接暂时没找到方法带Title</p></blockquote><p>  <a href="https://i.loli.net/2018/09/16/5b9dbce0bac35.png" title="测试链接" target="_blank" rel="noopener">测试链接</a></p><pre><code class="markdown">  [测试链接](https://i.loli.net/2018/09/16/5b9dbce0bac35.png &quot;测试链接&quot;)</code></pre></li></ul></li></ul><h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><p><img src="https://i.loli.net/2018/09/16/5b9dbce0bac35.png" alt="测试"></p><ul><li>添加本地图片<blockquote><p>同级目录开始索引，部署到GitHub后会变成从根目录开始索引,因此务必要用一个专门的文件夹来储存图片</p></blockquote></li></ul><pre><code class="markdown">![测试](测试.png)</code></pre><ul><li>添加网络图片<pre><code class="markdown">![测试](https://i.loli.net/2018/09/16/5b9dbce0bac35.png)</code></pre></li><li>可复用的图片链接<br>  <img src="https://i.loli.net/2018/09/16/5b9dbce0bac35.png" alt="测试图片" title="测试图片"></li></ul><pre><code class="markdown{.line-numbers}">![测试链接][1]**//注意最少要有一个空行的间隙**[1]:https://i.loli.net/2018/09/16/5b9dbce0bac35.png &quot;测试链接&quot;</code></pre><ul><li>分享音频<blockquote><p>部分主题支持调用的网页内嵌播放器不一样</p></blockquote></li></ul><div align="center"><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29199725&auto=0&height=66"></iframe><br></div><ul><li>分享视频<blockquote><p>同音频一样部分主题支持的播放器不一样，有些网站可以有些不行。可以在网站的分享界面获得外链的内嵌代码。</p></blockquote></li></ul><div align="center"><br><iframe src="//player.bilibili.com/player.html?aid=8819726&cid=14549684&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="70%" height="500px"> </iframe><br></div><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>下面嵌套一个<strong>代码</strong></p><pre><code class="c#{.line-numbers}"> Console.WriteLine(&quot;TestCode&quot;); Console.WriteLine(&quot;TestCode&quot;); Console.WriteLine(&quot;TestCode&quot;);</code></pre></blockquote><pre><code>&gt;下面嵌套一个**代码**&gt; ```c#{.line-numbers} Console.WriteLine(&quot;TestCode&quot;); Console.WriteLine(&quot;TestCode&quot;); Console.WriteLine(&quot;TestCode&quot;);</code></pre><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>两个以上<code>*</code>或者<code>_</code></p><hr><pre><code class="markdown">****</code></pre><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p>这是一整行句子，我要在这里插入代码<code>code</code></p><pre><code class="markdown">这是一整行句子，我要在这里插入代码`code`</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><pre><code class="c#{.line-numbers}">Console.WriteLine(&quot;TestCode&quot;);Console.WriteLine(&quot;TestCode&quot;);Console.WriteLine(&quot;TestCode&quot;);</code></pre><ul><li>加<code>c#{.line-numbers}</code> 代表指定语言和显示代码行数<blockquote><p>以下显示的效果为不加<code>{.line-numbers}</code>的样子<br>部分主题默认显示代码行数</p></blockquote></li></ul><pre><code class="c#">    Console.WriteLine(&quot;TestCode&quot;);    Console.WriteLine(&quot;TestCode&quot;);    Console.WriteLine(&quot;TestCode&quot;);</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><blockquote><p>在<code>--</code>的左或者右打上<code>:</code>可以决定对齐方式。两边都打为居中</p></blockquote><table><thead><tr><th style="text-align:right">第一列</th><th style="text-align:left">第二列</th><th style="text-align:center">第三列 </th></tr></thead><tbody><tr><td style="text-align:right"> 1</td><td style="text-align:left">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:right"> 3</td><td style="text-align:left">1</td><td style="text-align:center"></td><td></td></tr></tbody></table><blockquote><p>原生Markdown语法不支持表格合并等高级操作，需要添加插件实现</p></blockquote><pre><code class="markdown"> 第一列 | 第二列|第三列  --:|:--|:--: 1 | 2|3 3 | 1| |</code></pre><hr><p>以上语法已支持绝大多数创作所需，以下语法可以根据所用的编辑器支持和自身情况进行适当的扩展</p><hr><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>根据主题渲染方式有不同的语法支持，比较常用的有<a href="https://github.com/Khan/KaTeX" target="_blank" rel="noopener">KaTex</a>和<a href="https://github.com/mathjax/MathJax" target="_blank" rel="noopener">MathJax</a>两种</p><blockquote><p>下面应该会写MathJax的语法</p></blockquote><p><strong>TODO..</strong></p><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p><strong>TODO..</strong><br><a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">参考链接</a></p><h2 id="目录列表-TOC"><a href="#目录列表-TOC" class="headerlink" title="目录列表(TOC)"></a>目录列表(TOC)</h2><p>某些主题会有自己相应的TOC生成方式，详情看自己应用的主题说明</p><blockquote><p>一般情况下在想要插入目录的位置写上<code>[TOC]</code>就可以实现目录的插入</p></blockquote><h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><blockquote><p>现在使用的hexo主题Yelee并不支持以下语法效果(2018.9.19)</p></blockquote><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><p>我要一个上标<b>^给你^</b>,谢谢<br>12^th^</p><pre><code class="markdown{.line-numbers}">我要一个上标&lt;b&gt;^给你^&lt;/b&gt;,谢谢12^th^</code></pre><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>H<b>~2~</b>O~2~</p><pre><code class="markdown">H&lt;b&gt;~2~&lt;/b&gt;O~2~</code></pre><h3 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h3><p>我需要一个注脚[^5]<br>[^5]:这是一个注脚</p><blockquote><p>注脚在编辑时可以写在任意位置</p><pre><code class="markdown{.line-numbers}">我需要一个注脚[^5][^5]:这是一个注脚</code></pre></blockquote><h3 id="文本说明"><a href="#文本说明" class="headerlink" title="文本说明"></a>文本说明</h3><p><em>[HTML]:Hyper Text Markup Language<br>The HTML specification<br>我 不明白。</em>[不明白]:你必须明白</p><blockquote><p>鼠标悬停时可以看到对一个关键词的解释说明<br>说明文本可以在任意地方</p><pre><code class="markdown{.line-numbers}">*[HTML]:Hyper Text Markup LanguageThe HTML specification我 不明白。**//注意空格***[不明白]:你必须明白</code></pre></blockquote><h3 id="高亮文本"><a href="#高亮文本" class="headerlink" title="高亮文本"></a>高亮文本</h3><p>==我需要发光==</p><pre><code class="markdown">==我需要发光==</code></pre><h3 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h3><p><a href="http://moxfive.coding.me/yelee/2.Basic-Usage/post-excerpt.html" target="_blank" rel="noopener">文章摘要</a></p><h3 id="GitHub-仓库展示小挂件"><a href="#GitHub-仓库展示小挂件" class="headerlink" title="GitHub 仓库展示小挂件"></a>GitHub 仓库展示小挂件</h3><p><a href="http://moxfive.coding.me/yelee/5.Vendor/github-repo-widget.html" target="_blank" rel="noopener">GitHub 仓库展示小挂件</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">https://daringfireball.net/projects/markdown/</a></li><li><a href="https://www.jianshu.com/p/8c1b2b39deb0" target="_blank" rel="noopener">https://www.jianshu.com/p/8c1b2b39deb0</a></li><li><a href="https://blog.csdn.net/wybluewind/article/details/47752597" target="_blank" rel="noopener">https://blog.csdn.net/wybluewind/article/details/47752597</a></li><li><a href="https://segmentfault.com/markdown#articleHeader2" target="_blank" rel="noopener">https://segmentfault.com/markdown#articleHeader2</a></li><li><a href="https://blog.csdn.net/witnessai1/article/details/52551362" target="_blank" rel="noopener">https://blog.csdn.net/witnessai1/article/details/52551362</a></li><li><a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">https://guides.github.com/features/mastering-markdown/</a></li><li><a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics" target="_blank" rel="noopener">https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics</a></li><li><a href="http://moxfive.xyz/2015/08/30/EndNote-Markdown/" target="_blank" rel="noopener">http://moxfive.xyz/2015/08/30/EndNote-Markdown/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 语法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
